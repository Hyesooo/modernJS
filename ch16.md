## 💡 ch.16 프로퍼티 어트리뷰트

### ✔️ 16.1 내부 슬롯과 내부 메서드
> 모든 객체는 [[prototype]] 이라는 내부 슬롯을 갖는다.
> 
> 원칙적으로 내부 슬롯은 직접 접근할 수 없지만 \_\_proto\_\_를 통해 접근 가능하다
>

### ✔️ 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체
> 모든 프로퍼티는 value, writable(값 갱신 가능 여부), enumerable, configurable(객체 정의 가능 여부)을 프로퍼티 어트리뷰트로 갖는다.
>
> ```console.log(Object.getOwnPropertyDescriptor(person, name))```
>
> 프로퍼티 디스크립터 객체를 반환 -> ```{value: '', writable: true, enumerable: true, configurable: true}```

### ✔️ 16.3 데이터 프로퍼티와 접근자 프로퍼티
> 데이터 프로퍼티 : 일반적인 프로퍼티
>
> 접근자 프로퍼티 : 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티
>
> 데이터 프로퍼티를 추가할 때 value, writable(값 갱신 가능 여부), enumerable, configurable(객체 정의 가능 여부)을 프로퍼티 어트리뷰트를 갖게 되며 writable(값 갱신 가능 여부), enumerable, configurable(객체 정의 가능 여부)는 기본적으로 true로 세팅된다.
>
> 접근자 프로퍼티는 get, set, enumerable, configurable을 어트리뷰트로 갖는다.
> 
> 정의한 getter, setter 함수의 이름이 접근자 프로퍼티가 되는 것으로 함수처럼 보이나 프로퍼티이다. 다만 자체적으로 value를 가지지는 못함
>
> ```프로토타입 ? 어떤 객체의 상위 객체 역할을 한느 객체, 프로토타입 체인은 프로토타입이 단방향 링크드 리스트 형태로 연결되어 있는 상속 구조를 말한다.```

### ✔️ 16.4 프로퍼티 정의
> ```defineProperty```를 통해 데이터 프로퍼티 어트리뷰트를 정의할 수 있다.

### ✔️ 16.5 객체 변경 방지
> Object.preventExtensions ? 객체 확장 금지로 확장이 금지된 객체는 프로퍼티 추가가 금지된다.
>
> Object.seal ? 객체 밀봉으로 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의를 금지한다.
>
> Object.freeze ? 객체 동결로 seal에서 더 나아가 프로퍼티 값 갱신도 금지한다.
>
> 불변객체 ? 위의 방법은 얕은 객체 변경 방지로 중첩된 객체까지 영향주지는 못한다. 따라서 재귀적으로 Object.freeze를 호출해야 한다.
>

## 💡 ch.17 생성자 함수에 의한 객체 생성
### ✔️ 17.1 Object 생성자 함수
> 생성자 함수에 의해 생성된 객체를 인스턴스라 한다.
>
>  일반함수 처럼 정의하고 new 키위드와 함께 쓰면 생성자 함수가 된다.
>
> this.프로퍼티 형식으로 this(인스턴스 객체)에 프로퍼티를 추가하고 필요에 따라 전달된 인수로 초기화한다.
>
> 생성자 함수 정의시 암묵적으로 인스턴스가 생성되고 this에 바인딩 된다. 따라서 생성자 함수 내에서 this는 생성된 인스턴스 그 자체
>
> 암묵적으로 this가 return된다.
>
### ✔️ 17.2 내부메서드 call 과 construct
> 함수는 내부적으로 call과 construct 메서드를 가지고 있는데, 일반 함수로 호출되면 call을 new 키워드로 호출되면 construct를 실행한다.
>
> 함수 선언문과 함수 표현식으로 정의된 함수만 constructor, arrow function은 non-constructor이다.
>
> 생성자 함수는 보통 파스칼 케이스로 명명하여 구별한다.
>
> new.target 은 해당 함수가 new 키워드와 함께 호출된 것인지 판단 가능하게 하는 지표
