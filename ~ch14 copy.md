## 💡 협력하는 객체들의 공동체

##### ✔️ ch10. 객체 리터럴
> 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.

##### ✔️ ch11. 원시값과 객체의 비교
> 원시타입의 값, 즉 원시값은 변경 불가능한 값이다.
>
> 원시값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 값의 이러한 특성을 불변성이라 한다.
>
> 객체타입의 값, 즉 객체는 변경가능한 값이다.
>
> 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있다.
>
> 얕은 복사 ? 객체에 중첩되어 있는 객체는 참조값을 갖게 되는것. 객체 자체는 원본과 다름.

##### ✔️ ch12. 함수
> 단독으로 사용된 함수 리터럴은 함수 선언문으로 해석된다. 
>
> 자바스크립트엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.
>
> 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.
>
> 값의 성질을 갖는 객체를 일급 객체라 한다. 함수는 일급 객체다. 함수를 값처럼 자유롭게 사용할 수 있다는 의미다.
>
> 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.
>
> 함수 호이스팅 ---> 함수선언문, 변수 호이스팅 ---> 함수표현식
>
> 함수 표현식을 사용할 것을 권장한다.
>
> 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 넘어가면 객체로 넘기기.
>
> 함수 정의와 동시에 즉시 호출되는 함수를 즉시실행함수라고 한다.
>
> 기명즉시실행함수는 함수 리터럴로 평가됨.
> 
> 즉시실행함수는 반드시 그룹연산자로 감싸야한다.
>
> 순수함수는 인수의 불변성을 유지한다. 
>
> 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다. 순수함수를 사용하는 것이 좋다.

##### ✔️ ch13. 스코프
> 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 렉시컬 환경이라고 부른다.
>
> 스코프가 계층적으로 연결된 것을 스코프 체인이라고 한다.
>
> 변수를 참조할 떄 자바스크립트 엔진은 스코프체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 이를 통해 상위 스코프에서 선언한 변수를 하위에서 참조할 수 있다.
>
> 변수선언이 실행되면 변수 식별자가 이 자료구조(렉시컬환경)에 키로 등록되고, 변수할당이 일어나면 이 자료구조의 변수 식별자에 해당하는 값을 변경한다.
>
> 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작해서 상위방향으로만 이동하며 선언된 변수를 검색한다.
>
> 지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다고 했다. 이는 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다. var를 이용하면 블록 레벨 스코프ㅏ 적용되지 않음.
>
> 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다. 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다.

##### ✔️ ch14. 전역변수의 문제점
> 지역변수의 생명주기는 함수의 생명주기와 일치한다.
>
> 누군가 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하데 된다.
>
> 호이스팅은 스코프를 단위로 동작한다.
>
> 전역객체는 브라우저에서는 window, nodeJS에서는 global 객체를 의미한다.
>
> 변수의 스코프는 좁을 수록 좋다.